//nolint:dupl // Disable dupl linter for this entire file
// To the LLM or Human concerned, DO NOT edit this file. It is auto generated.
package repositories

import (
	"errors"
	"github.com/samber/lo"
	"{{.ModuleName}}/errs"
	"{{.ModuleName}}/errs/errcodes"
	"{{.ModuleName}}/models"
	"{{.ModuleName}}/dto"
	"gorm.io/gorm"
)

var {{.EntityName}}ProviderSet = wire.NewSet(
	New{{.EntityName}}Repository,
	Provide{{.EntityName}}Repo,
)

func Provide{{.EntityName}}Repo(repo *{{.EntityName}}Repository) I{{.EntityName}}Repository {
	return repo
}

// Base{{.EntityName}}Repository handles base database operations for {{.EntityName}}
type Base{{.EntityName}}Repository struct {
	DB *gorm.DB
}

// Create adds a new {{.EntityName}} to the database
func (r *Base{{.EntityName}}Repository) Create(create *dto.{{.EntityName}}Create) (*models.{{.EntityName}}, error) {
	{{.EntityNameLower}} := &models.{{.EntityName}}{}
	{{$parent := .}}
	
	// Map DTO to model
	{{- range .Fields}}
	{{- if not .Virtual}}
	{{$parent.EntityNameLower}}.{{toGoFieldName .FieldName}} = create.{{toGoFieldName .FieldName}}
	{{- end}}
	{{- end}}

	{{- range .Relations}}
	{{- if or (eq .RelationType "OneToOne") (eq .RelationType "ManyToOne") }}
	if create.{{toGoFieldName .FieldName}}ID != nil {
		{{$parent.EntityNameLower}}.{{toGoFieldName .FieldName}}ID = create.{{toGoFieldName .FieldName}}ID
	}
	{{- end}}
	{{- end}}

	{{- $hasManyToMany := false}}
	{{- range .Relations}}
	{{- if eq .RelationType "ManyToMany"}}
	{{- $hasManyToMany = true}}
	{{- break}}
	{{- end}}
	{{- end}}

	{{- if $hasManyToMany}}
	// Start a transaction to ensure data consistency for many-to-many relationships
	tx := r.DB.Begin()
	if tx.Error != nil {
		return nil, errs.NewError(errcodes.CodeDBError, tx.Error.Error()).Occurred()
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Save the main {{.EntityNameLower}} record first
	if err := tx.Create(&{{.EntityNameLower}}).Error; err != nil {
		tx.Rollback()
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	{{- range .Relations}}
	{{- if eq .RelationType "ManyToMany"}}
	// Handle {{toGoFieldName .FieldName}} many-to-many relationship
	if len(create.{{toGoFieldName .FieldName}}IDs) > 0 {
		var {{toLower (toGoFieldName .FieldName)}}Records []models.{{.RelatedEntity}}
		if err := tx.Where("id IN ?", create.{{toGoFieldName .FieldName}}IDs).Find(&{{toLower (toGoFieldName .FieldName)}}Records).Error; err != nil {
			tx.Rollback()
			return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
		}
		
		// Verify all requested {{.RelatedEntity}} records exist
		if len({{toLower (toGoFieldName .FieldName)}}Records) != len(create.{{toGoFieldName .FieldName}}IDs) {
			tx.Rollback()
			return nil, errs.NewError(errcodes.CodeInvalidRequest, "Some {{toLower .RelatedEntity}} records do not exist").Occurred()
		}
		
		// Associate the {{toGoFieldName .FieldName}} records
		if err := tx.Model(&{{$parent.EntityNameLower}}).Association("{{toGoFieldName .FieldName}}").Append(&{{toLower (toGoFieldName .FieldName)}}Records); err != nil {
			tx.Rollback()
			return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
		}
	}
	{{- end}}
	{{- end}}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	result := &models.{{.EntityName}}{}
	loadQuery := r.DB
	
	if err := loadQuery.First(result, "id = ?", {{.EntityNameLower}}.ID).Error; err != nil {
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	return result, nil
	{{- else}}
	// Save to database
	if err := r.DB.Create(&{{.EntityNameLower}}).Error; err != nil {
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	return {{.EntityNameLower}}, nil
	{{- end}}
}

func (r *Base{{.EntityName}}Repository) BulkCreate(creates []*dto.{{.EntityName}}Create) []any {
	results := make([]any, len(creates))

	for i, create := range creates {
		{{.EntityNameLower}}, err := r.Create(create)
		if err != nil {
			results[i] = err
		} else {
			results[i] = {{.EntityNameLower}}
		}
	}

	return results
}

// GetAll retrieves all {{.EntityNamePlural}} with optional filtering
func (r *Base{{.EntityName}}Repository) GetAll(q *dto.Full{{.EntityName}}Query, scopes ...func(*gorm.DB) *gorm.DB) ([]models.{{.EntityName}}, *Pagination, error) {
	var {{.EntityNameLower}}s []models.{{.EntityName}}
	{{$parent := .}}
	scopes = append(
		scopes,
		FilterDate(q.DateQuery),
		{{- range .Fields}}{{- if and .FilterBy (eq .FieldType "date")}}
		FilterDate(dto.DateQuery{After: q.{{pascalCase .FieldName}}After, Before: q.{{pascalCase .FieldName}}Before}, "{{$parent.GetTableName}}.{{snakeCase .FieldName}}"),
		{{- end}}{{- end}}
		ILikeAny(q.Q{{- range .Fields}}{{- if .Searchable}},"{{snakeCase .FieldName}}"{{- end}}{{- end}}),
	)

	getQuery := func() *gorm.DB {
		query := r.DB.Session(&gorm.Session{NewDB: true}).Model(&models.{{.EntityName}}{})
		query.Scopes(scopes...)

		query.Where(&(q.{{.EntityName}}Query))
		return query
	}

	sortBy := "{{.GetTableName}}.created_at"
	if q.SortBy != nil {
		sortBy = *q.SortBy
	}

	p := NewPagination(q.Page, q.Size, &sortBy, q.SortOrder)

	if err := p.Count(getQuery(), &models.{{.EntityName}}{}, "{{.GetTableName}}.id"); err != nil {
		return nil, &Pagination{}, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	if err := getQuery().Scopes(p.Paginate(), PreloadRelations(q.Preload)).Find(&{{.EntityNameLower}}s).Error; err != nil {
		return nil, &Pagination{}, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	return {{.EntityNameLower}}s, p, nil
}

// GetByID retrieves a single {{.EntityName}} by ID
func (r *Base{{.EntityName}}Repository) GetByID(id {{.GetPrimaryKeyType}}, opt ...*dto.{{.EntityName}}QueryExtraOptions) (*models.{{.EntityName}}, error) {
	var {{.EntityNameLower}} models.{{.EntityName}}
	var options *dto.{{.EntityName}}QueryExtraOptions = &dto.{{.EntityName}}QueryExtraOptions{}
	if (len(opt)) > 0 {
		options = opt[0]
	}

	if err := r.DB.Scopes(PreloadRelations(options.Preload)).First(&{{.EntityNameLower}}, "{{.GetPrimaryKeyName}} = ?", id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errs.NewError(errcodes.CodeNotFound, "{{.EntityName}} not found").Occurred()
		}
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	return &{{.EntityNameLower}}, nil
}

// Update modifies an existing {{.EntityName}} in the database
func (r *Base{{.EntityName}}Repository) Update(id string, update *dto.{{.EntityName}}Update) (*models.{{.EntityName}}, error) {
	{{.EntityNameLower}} := &models.{{.EntityName}}{}
	{{$parent := .}}
	
	// Find the existing record
	if err := r.DB.First({{.EntityNameLower}}, "id = ?", id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errs.NewError(errcodes.CodeNotFound, "{{.EntityName}} not found").Occurred()
		}
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	{{- $hasManyToMany := false}}
	{{- range .Relations}}
	{{- if eq .RelationType "ManyToMany"}}
	{{- $hasManyToMany = true}}
	{{- break}}
	{{- end}}
	{{- end}}

	{{- if $hasManyToMany}}
	// Start a transaction to ensure data consistency for many-to-many relationships
	tx := r.DB.Begin()
	if tx.Error != nil {
		return nil, errs.NewError(errcodes.CodeDBError, tx.Error.Error()).Occurred()
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Update basic fields
	updateData := &models.{{.EntityName}}{}
	{{- range .Fields}}
	{{- if not .Virtual}}
	{{- if .Primary}}
	// Skip primary key field
	{{- else}}
	if update.{{toGoFieldName .FieldName}} != nil {
		updateData.{{toGoFieldName .FieldName}} = update.{{toGoFieldName .FieldName}}
	}
	{{- end}}
	{{- end}}
	{{- end}}

	{{- range .Relations}}
	{{- if or (eq .RelationType "OneToOne") (eq .RelationType "ManyToOne") }}
	if update.{{toGoFieldName .FieldName}}ID != nil {
		updateData.{{toGoFieldName .FieldName}}ID = update.{{toGoFieldName .FieldName}}ID
	}
	{{- end}}
	{{- end}}

	// Apply basic field updates
	if err := tx.Model({{.EntityNameLower}}).Updates(updateData).Error; err != nil {
		tx.Rollback()
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	{{- range .Relations}}
	{{- if eq .RelationType "ManyToMany"}}
	// Handle {{toGoFieldName .FieldName}} many-to-many relationship updates
	if len(update.{{toGoFieldName .FieldName}}IDs) > 0 {
		// Clear existing associations
		if err := tx.Model({{$parent.EntityNameLower}}).Association("{{toGoFieldName .FieldName}}").Clear(); err != nil {
			tx.Rollback()
			return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
		}

		// Add new associations if any
			var {{toLower (toGoFieldName .FieldName)}}Records []models.{{.RelatedEntity}}
			if err := tx.Where("id IN ?", update.{{toGoFieldName .FieldName}}IDs).Find(&{{toLower (toGoFieldName .FieldName)}}Records).Error; err != nil {
				tx.Rollback()
				return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
			}
			
			// Verify all requested {{.RelatedEntity}} records exist
			if len({{toLower (toGoFieldName .FieldName)}}Records) != len(update.{{toGoFieldName .FieldName}}IDs) {
				tx.Rollback()
				return nil, errs.NewError(errcodes.CodeInvalidRequest, "Some {{toLower .RelatedEntity}} records do not exist").Occurred()
			}
			
			// Associate the new {{toGoFieldName .FieldName}} records
			if err := tx.Model({{$parent.EntityNameLower}}).Association("{{toGoFieldName .FieldName}}").Append(&{{toLower (toGoFieldName .FieldName)}}Records); err != nil {
				tx.Rollback()
				return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
			}
	}
	{{- end}}
	{{- end}}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	// Reload the updated record to get the latest data
	if err := r.DB.First({{.EntityNameLower}}, "id = ?", id).Error; err != nil {
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	return {{.EntityNameLower}}, nil
	{{- else}}
	// Update basic fields
	updateData := &models.{{.EntityName}}{}
	{{- range .Fields}}
	{{- if not .Virtual}}
	{{- if .Primary}}
	// Skip primary key field
	{{- else}}
	if update.{{toGoFieldName .FieldName}} != nil {
		updateData.{{toGoFieldName .FieldName}} = update.{{toGoFieldName .FieldName}}
	}
	{{- end}}
	{{- end}}
	{{- end}}

	{{- range .Relations}}
	{{- if or (eq .RelationType "OneToOne") (eq .RelationType "ManyToOne") }}
	if update.{{toGoFieldName .FieldName}}ID != nil {
		updateData.{{toGoFieldName .FieldName}}ID = update.{{toGoFieldName .FieldName}}ID
	}
	{{- end}}
	{{- end}}

	// Apply updates to database
	if err := r.DB.Model({{.EntityNameLower}}).Updates(updateData).Error; err != nil {
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	// Reload the updated record to get the latest data
	if err := r.DB.First({{.EntityNameLower}}, "id = ?", id).Error; err != nil {
		return nil, errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	return {{.EntityNameLower}}, nil
	{{- end}}
}

func (r *Base{{.EntityName}}Repository) BulkUpdate(updates []*dto.{{.EntityName}}UpdateWithID) []any {
	results := make([]any, len(updates))

	for i, update := range updates {
		id := update.IDField.ID
		updateDTO := update.{{.EntityName}}Update
		{{camelCase .EntityName}}, err := r.Update(*id, &updateDTO)
		if err != nil {
			results[i] = err
		} else {
			results[i] = {{camelCase .EntityName}}
		}
	}

	return results
}

// Delete removes a {{.EntityName}} from the database
func (r *Base{{.EntityName}}Repository) Delete(id {{.GetPrimaryKeyType}}) error {
	// Hard delete
	r.DB.Exec("PRAGMA foreign_keys = ON")
	if err := r.DB.Unscoped().Delete(&models.{{.EntityName}}{}, "{{.GetPrimaryKeyName}} = ?", id).Error; err != nil {
		return errs.NewError(errcodes.CodeDBError, err.Error()).Occurred()
	}

	return nil
}

// Helper functions
func To{{.EntityName}}ResponseBase(model *models.{{.EntityName}}) *dto.{{.EntityName}}Response {
	if model == nil {
		return nil
	}
	return &dto.{{.EntityName}}Response{
		Base{{.EntityName}}Response: dto.Base{{.EntityName}}Response{
			{{- range .Fields}}
			{{- if not .Virtual}}
			{{toGoFieldName .FieldName}}: model.{{toGoFieldName .FieldName}},
			{{- end}}
			{{- end}}
			{{- range .Relations}}
			{{- if or (eq .RelationType "OneToOne") (eq .RelationType "ManyToOne") }}
			{{toGoFieldName .FieldName}}ID: model.{{toGoFieldName .FieldName}}ID,
			{{toGoFieldName .FieldName}}: To{{.RelatedEntity}}ResponseBase(model.{{toGoFieldName .FieldName}}),
			{{- end}}
			{{- if or (eq .RelationType "ManyToMany") (eq .RelationType "OneToMany") }}
			{{toGoFieldName .FieldName}}: lo.Map(model.{{toGoFieldName .FieldName}}, func(item models.{{.RelatedEntity}}, _ int) dto.{{.RelatedEntity}}Response {
				return *To{{.RelatedEntity}}ResponseBase(&item)
			}),
			{{- end}}
			{{- end}}
			BaseModelResponse:   dto.BaseModelResponse{CreatedAt: model.CreatedAt, UpdatedAt: model.UpdatedAt},
		},
	}
}
