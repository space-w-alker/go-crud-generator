// To the LLM or Human concerned, DO NOT edit this file. It is auto generated.
package dto

import (
	"time"
)

// Base{{.EntityName}}Create DTO for creating a new {{.EntityName}}
type Base{{.EntityName}}Create struct {
	{{- range .Fields}}
	{{- if not .Virtual}}
	{{toGoFieldName .FieldName}} *{{convertTypeScriptTypeToGo .FieldType}} `json:"{{.FieldName}},omitempty" form:"{{.FieldName}}" binding:"{{formatValidationRules .}}"`
	{{- end}}
	{{- end}}
	{{- range .Relations}}
  {{- if or (eq .RelationType "OneToOne") (eq .RelationType "ManyToOne") }}
	{{toGoFieldName .FieldName}}ID *{{relatedIDType .}} `json:"{{.FieldName}}ID,omitempty" form:"{{.FieldName}}ID"`
	{{- end}}
  {{- if (eq .RelationType "ManyToMany") }}
	{{toGoFieldName .FieldName}}IDs []{{relatedIDType .}} `json:"{{.FieldName}}IDs,omitempty" form:"{{.FieldName}}IDs"`
	{{- end}}
	{{- end}}
}

type {{.EntityName}}BulkCreate struct {
  {{.EntityName}}s []*{{.EntityName}}Create `json:"{{camelCase .EntityNamePlural}}" binding:"required,min=1"`
}

// {{.EntityName}}Update DTO for updating an existing {{.EntityName}}
type Base{{.EntityName}}Update struct {
	{{- range .Fields}}
  {{- if and (not .Primary) (not .Virtual)}}
	{{toGoFieldName .FieldName}} *{{convertTypeScriptTypeToGo .FieldType}} `json:"{{.FieldName}},omitempty" form:"{{.FieldName}}"`
  {{- end}}
	{{- end}}
	{{- range .Relations}}
  {{- if or (eq .RelationType "OneToOne") (eq .RelationType "ManyToOne") }}
	{{toGoFieldName .FieldName}}ID *{{relatedIDType .}} `json:"{{.FieldName}}ID,omitempty" form:"{{.FieldName}}ID"`
	{{- end}}
  {{- if (eq .RelationType "ManyToMany") }}
	{{toGoFieldName .FieldName}}IDs []{{relatedIDType .}} `json:"{{.FieldName}}IDs,omitempty" form:"{{.FieldName}}IDs"`
	{{- end}}
	{{- end}}
}

type {{.EntityName}}UpdateWithID struct {
	IDField
	{{.EntityName}}Update
}

type {{.EntityName}}BulkUpdate struct {
  {{.EntityName}}s []*{{.EntityName}}UpdateWithID `json:"{{camelCase .EntityNamePlural}}" binding:"required,min=1"`
}

// Base{{.EntityName}}Response DTO for responding with {{.EntityName}} data
type Base{{.EntityName}}Response struct {
	{{- range .Fields}}
	{{toGoFieldName .FieldName}} *{{convertTypeScriptTypeToGo .FieldType}} `json:"{{.FieldName}}" form:"{{.FieldName}}"`
	{{- end}}
	{{- range .Relations}}
	{{formatRelationDTO .}}
	{{- end}}
  BaseModelResponse
}

type Paginated{{.EntityName}}Response struct {
	PaginationResponse
	Items []*{{.EntityName}}Response `json:"items"`
}

// {{.EntityName}}Query DTO for querying {{.EntityName}} data
type {{.EntityName}}Query struct {
  {{- range .Fields}}
  {{- if and .FilterBy (ne .FieldType "date") (not .Virtual) }}
  {{toGoFieldName .FieldName}} *{{convertTypeScriptTypeToGo .FieldType}} `form:"{{.FieldName}},omitempty" json:"{{.FieldName}},omitempty"`
  {{- end}}
  {{- end}}
	{{- range .Relations}}
  {{- if or (eq .RelationType "OneToOne") (eq .RelationType "ManyToOne") }}
	{{toGoFieldName .FieldName}}ID *{{relatedIDType .}} `form:"{{.FieldName}}ID,omitempty" json:"{{.FieldName}}ID,omitempty"`
	{{- end}}
	{{- end}}
}


type Full{{.EntityName}}Query struct {
  DateQuery
	PaginationQuery
  {{.EntityName}}Query
  {{.EntityName}}QueryExtraOptions
}
